package experiment;
/**
 * TestBoard 
 *  
 * @author Benny Hoang
 * @author William O'Byrne
 * @author Steven Nguyen
 * 
 * Purpose: 4x4 board
 */
import java.util.ArrayList;
import java.util.HashSet;

/**
 * Simple 4x4 board used for the early Clue Paths assignments.
 */
public class TestBoard {
    public ArrayList<ArrayList<TestBoardCell>> board;
    private HashSet<TestBoardCell> targets;
    public final int COLS = 4;
    public final int ROWS = 4;

    /** Construct the board and build adjacencies. */
    public TestBoard() {
        board = new ArrayList<>();
        for (int i = 0; i < ROWS; i++) {
            board.add(new ArrayList<>());
            for (int j = 0; j < COLS; j++) {
                board.get(i).add(new TestBoardCell(i, j));
            }
        }

        for (int i = 0; i < ROWS; i++) {
            for (int j = 0; j < COLS; j++) {
                TestBoardCell cell = getCell(i, j);
                if (i > 0) cell.addAdjacency(getCell(i - 1, j));
                if (i < ROWS - 1) cell.addAdjacency(getCell(i + 1, j));
                if (j > 0) cell.addAdjacency(getCell(i, j - 1));
                if (j < COLS - 1) cell.addAdjacency(getCell(i, j + 1));
            }
        }
    }

    /** Calculate all movement targets from a start cell and path length. */
    public void calcTargets(TestBoardCell startCell, int pathLength) {
        targets = new HashSet<>();
        HashSet<TestBoardCell> visited = new HashSet<>();
        findAllTargets(startCell, pathLength, visited);
    }

    /** Recursive helper to explore movement paths. */
    private void findAllTargets(TestBoardCell currentCell, int stepsRemaining,
                                HashSet<TestBoardCell> visited) {
        visited.add(currentCell);
        for (TestBoardCell neighbor : currentCell.getAdjList()) {
            if (visited.contains(neighbor) || neighbor.isOccupied()) {
                continue;
            }

            if (stepsRemaining == 1 || neighbor.isRoom()) {
                targets.add(neighbor);
            } else {
                findAllTargets(neighbor, stepsRemaining - 1, visited);
            }
        }
        visited.remove(currentCell);
    }

    /** Retrieve a specific board cell. */
    public TestBoardCell getCell(int row, int column) {
        return board.get(row).get(column);
    }

    /** Targets generated by the most recent call to calcTargets(). */
    public HashSet<TestBoardCell> getTargets() {
        return targets;
    }
}